<?php

namespace DigitalPolygon\Polymer\Robo\Config;

use Consolidation\Config\Config;
use Consolidation\Config\Config as ConsolidationConfig;
use Consolidation\Config\ConfigInterface;
use Consolidation\Config\Loader\YamlConfigLoader;
use Robo\Config\Config as RoboConfig;

/**
 * Default configuration for Polymer.
 */
class PolymerConfig extends RoboConfig
{
    /**
     * DefaultConfig constructor.
     *
     * @param string $repo_root
     *   The repository root of the project that depends on Polymer.
     */
    public function __construct($repo_root)
    {
        parent::__construct();
        $this->setDefault('repo.root', $repo_root);
        $this->setDefault('docroot', $repo_root . '/web');
        $this->setDefault('polymer.root', $this->getPolymerRoot());
        $this->setDefault('composer.bin', $repo_root . '/vendor/bin');
        $this->setDefault('tmp.dir', sys_get_temp_dir());

        $loader = new YamlConfigLoader();
        $polymerBaseConfig = $loader->load($this->getPolymerRoot() . '/config/default.yml')->export();
        $this->addContext('polymer', new ConsolidationConfig($polymerBaseConfig));
    }

    /**
     * Gets the Polymer root directory, e.g., /vendor/digitalpolygon/polymer.
     *
     * @return string
     *   THe filepath for the Polymer root.
     *
     * @throws \Exception
     */
    private function getPolymerRoot(): string
    {
        $possible_polymer_roots = [
            dirname(dirname(dirname(dirname(__FILE__)))),
            dirname(dirname(dirname(__FILE__))),
        ];
        foreach ($possible_polymer_roots as $polymer_root) {
            if (basename($polymer_root) !== 'polymer') {
                continue;
            }
            if (!file_exists("$polymer_root/src/Robo/Polymer.php")) {
                continue;
            }
            return $polymer_root;
        }
        throw new \Exception('Could not find the Polymer root directory');
    }

    /**
     * Reprocess all contexts in order to replace placeholders.
     *
     * Whenever contexts are modified this method should be called to ensure
     * tokens are replaced.
     *
     * There is an obvious issue where contexts are retrieved via getContext
     * and the configuration within is modified. The developer will need to
     * know that if they modify the configuration this way, and it contains
     * tokens, they will need to call reprocess to ensure the tokens are
     * replaced.
     *
     * @return void
     */
    public function reprocess(): void
    {
        $processor = new YamlConfigProcessor();
        $contexts = $this->exportAll();
        foreach ($contexts as $data) {
            $processor->add($data);
        }
        $allProcessedData = $processor->export();
        foreach ($contexts as $contextName => $data) {
            $processor = new YamlConfigProcessor();
            $processor->add($data);
            $processedContext = $processor->export($allProcessedData);
            /** @var Config $context */
            $context = $this->getContext($contextName);
            $context->replace($processedContext);
        }
    }

    public function removeContext($name): void
    {
        parent::removeContext($name);
        $this->reprocess();
    }

    public function addContext($name, ConfigInterface $config): PolymerConfig
    {
        $self = parent::addContext($name, $config); // TODO: Change the autogenerated stub
        $this->reprocess();
        return $self;
    }

    public function set($key, $value)
    {
        $self = parent::set($key, $value); // TODO: Change the autogenerated stub
        $this->reprocess();
        return $self;
    }

    /**
   * Set site.
   *
   * @param string $site
   *   Site name.
   */
//    public function setSite($site): void
//    {
//        $this->set('site', $site);
//        if (!$this->get('drush.uri') && $site != 'default') {
//            $this->set('drush.uri', $site);
//        }
//    }
}
